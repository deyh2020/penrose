-- Set the target diagram size
canvas {
   width = 240
   height = 180
}

-- A few colors used throughout
Colors {
   color black = rgba(0,0,0,1)
   color white = rgba(1,1,1,1)
   color clearGray = rgba(0,0,0,.2)
   color lightGray = rgba(.8,.8,.8,1.)
}

-- Global shapes and constants
Global {
   -- draw a box around the canvas
   shape box = Rectangle {
      center: (0,0)
      width: canvas.width
      height: canvas.height
      strokeColor: rgba(0.,0.,0.,.05)
      fillColor: none()
      strokeWidth: 1
   }

   string labelFont = "Linux Libertine O"
   string labelStyle = "italic"
   string labelSize = "9px"
   scalar labelSizeNum = 9

   -- default size for vertices, points, etc.
   scalar dotSize = 1.5
}

-- Draw each vertex as a little dot
forall Vertex v {

   vec2 v.center = (?,?)

   shape v.dot = Circle {
      fillColor: Colors.black
      r: Global.dotSize
      center: v.center
   }

   ensure contains( Global.box, v.dot )
}

-- Draw text for labeled vertices
forall Vertex v
where v has label {

   vec2 p = (?,?)

   shape v.labelText = Text {
      string: v.label
      fillColor: Colors.black
      fontFamily: Global.labelFont
      fontSize: Global.labelSize
      fontStyle: Global.labelStyle
      strokeColor: Colors.white
      strokeWidth: 2
      paintOrder: "stroke"
   }

   -- shape v.strokeText = Text {
   --    center: v.labelText.center
   --    string: v.label
   --    fillColor: Colors.white
   --    strokeColor: Colors.white
   --    strokeWidth: 2
   --    fontFamily: Global.labelFont
   --    fontSize: Global.labelSize
   --    fontStyle: Global.labelStyle
   --    ensureOnCanvas: false
   -- }
   --layer v.labelText above v.strokeText

   encourage near( v.labelText, v.dot )
   ensure disjoint( v.labelText, v.dot, 2. )
}

-- Draw each edge as a circular arc, as well as
-- a dashed line for the corresponding straight edge
forall Edge e; Vertex i; Vertex j
where e := MakeEdge(i,j) {

   vec2 a = i.center
   vec2 b = j.center

   -- pick the bend angle for the arc relative to the edge
   scalar e.alpha = ?
   scalar alpha0 = toRadians( 10. )
   scalar alpha1 = toRadians( 30. )
   ensure inRange( e.alpha, alpha0, alpha1 )

   shape e.segment = Line {
      start: a
        end: b
      strokeColor: Colors.clearGray
      strokeWidth: .85
      strokeDasharray: "2 1"
   }

   -- compute the arc radius r
   scalar w = norm( a-b ) -- segment length
   scalar h = (w/2.) / tan( e.alpha ) -- distance from segment midpoint to arc center
   scalar r = sqrt( w*w/4. + h*h ) -- arc radius

   -- compute the arc center c
   vec2 m = (a+b)/2.
   vec2 n = rot90(unit(b-a))
   vec2 c = m + h*n
   
   shape e.arc = Path {
      fillColor: none()
      strokeColor: Colors.black
      d: arc( "open", a, b, (r,r), 0., 0, 0 )
      strokeWidth: .75
      ensureOnCanvas: false
   }

   layer e.arc above e.segment

   -- associate some of this data with the edge
   -- itself, so that it can be used in later rules
   e.center = c
   e.radius = r
}

-- forall Vertex v; Edge e
-- where v has label {
--    ensure disjoint( v.strokeText, e.segment )
-- }

forall Edge e1; Edge e2 {
   layer e1.arc above e2.segment
   layer e2.arc above e1.segment
}

-- Make sure the shape of each triangle is reasonably nice
forall Triangle t; Vertex i; Vertex j; Vertex k
where t := MakeTriangle(i,j,k) {
   
   -- get the vertex positions
   vec2 a = i.center
   vec2 b = j.center
   vec2 c = k.center

   -- make sure the triangle is positively-oriented
   ensure greaterThan( cross2D(b-a,c-a), 0. )

   -- make sure the interior angles aren't too small/big
   scalar theta0 = toRadians( 30 )
   scalar theta1 = toRadians( 60 )
   scalar alpha = angleBetween( b-a, c-a )
   scalar  beta = angleBetween( c-b, a-b )
   ensure inRange( alpha, theta0, theta1 )
   ensure inRange( beta, theta0, theta1 )

}

-- Draw angles at corners of Euclidean triangles as arcs
forall Angle A; Vertex i; Vertex j; Vertex k
where A := EuclideanCorner(i,j,k) {
   
   -- get the vertex positions
   vec2 pi = i.center
   vec2 pj = j.center
   vec2 pk = k.center

   -- get unit vectors to neighbors
   vec2 u = unit(pj-pi)
   vec2 v = unit(pk-pi)

   -- compute the angle at the corner
   scalar θ = angleBetween( u, v )

   -- compute the radius r needed to
   -- achieve a target arc length s
   scalar s = 15
   scalar r = s/θ

   -- arc start and end location
   vec2 p = pi + r*u
   vec2 q = pi + r*v

   -- draw arc
   shape A.angleMarker = Path {
      fillColor: none()
      strokeColor: Colors.clearGray
      d: arc( "open", p, q, (A.r,A.r), 0., 0, 0 )
      strokeWidth: .75
      ensureOnCanvas: false
   }

   -- associate some of this data with the angle
   -- itself, so it can be accessed by later rules
   A.r = r
   A.u = u
   A.v = v
}

-- draw labels for Euclidean corner angles
forall Angle A; Vertex i; Vertex j; Vertex k
where A has label; A := EuclideanCorner(i,j,k) {

   scalar R = ?
   ensure greaterThan( R, 0 )

   scalar f = Global.labelSizeNum/2.
   vec2 p = i.center
   vec2 c = p + (f+A.r)*unit(A.u+A.v)
   
   A.labelText = Text {
      center: c
      string: A.label
      fillColor: Colors.clearGray
      fontFamily: Global.labelFont
      fontSize: Global.labelSize
      fontStyle: Global.labelStyle
      ensureOnCanvas: false
   }
}

-- draw an angle marker for each edge bending angle
forall Angle A; Edge e; Vertex i; Vertex j
where A := BendAngle(i,j); e := MakeEdge(i,j) {

   -- edge endpoints
   vec2 a = i.center
   vec2 b = j.center

   -- edge arc center and radius
   vec2 c = e.center
   scalar R = e.radius

   -- unit vectors from arc center to edge endpoints
   vec2 u = unit( a-c )
   vec2 v = unit( b-c )
   
   -- a point some fixed fraction along the edge arc
   vec2 p0 = c + R*unit( .75*u + .25*v )
   vec2 p1 = c + R*unit( .25*u + .75*v )

   -- the radius for the angle marker
   scalar r = norm( p0-a )

   -- the other endpoint of the angle marker is given by the
   -- intersection of the arc's circle with the straight edge
   vec2 q0 = a + r*unit(b-a)
   vec2 q1 = b + r*unit(a-b)

   -- draw arcs
   shape A.arc0 = Path {
      fillColor: none()
      strokeColor: Colors.clearGray
      d: arc( "open", p0, q0, (r,r), 0., 0, 0 )
      strokeWidth: .75
      ensureOnCanvas: false
   }
   shape A.arc1 = Path {
      fillColor: none()
      strokeColor: Colors.clearGray
      d: arc( "open", q1, p1, (r,r), 0., 0, 0 )
      strokeWidth: .75
      ensureOnCanvas: false
   }

   -- associate some of this data with the angle
   -- itself, so it can be accessed by later rules
   A.p0 = p0
   A.p1 = p1
   A.q0 = q0
   A.q1 = q1
   A.r = r
}

-- draw an angle marker for each edge bending angle
forall Angle A; Edge e; Vertex i; Vertex j
where A has label; A := BendAngle(i,j); e := MakeEdge(i,j) {

   scalar f = Global.labelSizeNum/2.

   vec2 w0 = unit( (A.p0+A.q0)/2. - i.center )
   vec2 c0 = i.center + (f+A.r)*w0

   vec2 w1 = unit( (A.p1+A.q1)/2. - j.center )
   vec2 c1 = j.center + (f+A.r)*w1
   
   shape A.labelText0 = Text {
      center: c0
      string: A.label
      fillColor: Colors.clearGray
      fontFamily: Global.labelFont
      fontSize: Global.labelSize
      fontStyle: Global.labelStyle
      ensureOnCanvas: false
   }
   
   shape A.labelText1 = Text {
      center: c1
      string: A.label
      fillColor: Colors.clearGray
      fontFamily: Global.labelFont
      fontSize: Global.labelSize
      fontStyle: Global.labelStyle
      ensureOnCanvas: false
   }
}

-- angle marker for interior angle of CAT
forall Angle A; Vertex i; Vertex j; Vertex k; Edge ij; Edge ki
where A := CATCorner( i, j, k ); ij := MakeEdge(i,j); ki := MakeEdge(k,i) {

   scalar markerArcLength = 20

   -- corner vertex positions
   vec2 pi = i.center
   vec2 pj = j.center
   vec2 pk = k.center

   -- edge arc data
   vec2 cIJ = ij.center
   vec2 cKI = ki.center
   scalar rIJ = ij.radius
   scalar rKI = ki.radius

   -- Euclidean interior angle
   scalar theta = angleBetween( pj-pi, pk-pi )
   -- CAT interior angle
   scalar beta = ij.alpha + ki.alpha + theta

   -- pick a radius for the arc that gives
   -- approximately the target arc length s
   -- (assuming s = rβ)
   scalar A.r = markerArcLength / beta

   -- start and end points for the corner arc
   vec2 p = circleCircleIntersection( cIJ, pi, rIJ, A.r )
   vec2 q = circleCircleIntersection( pi, cKI, A.r, rKI )

   shape angleMarker = Path {
      fillColor: none()
      strokeColor: Colors.clearGray
      d: arc( "open", p, q, (A.r,A.r), 0., 0, 0 )
      strokeWidth: .75
      ensureOnCanvas: false
   }
}

-- angle marker for interior angle of CAT
-- XXX opposite orientation
forall Angle A; Vertex i; Vertex j; Vertex k; Edge ij; Edge ki
where A := CATCorner( i, j, k ); ij := MakeEdge(j,i); ki := MakeEdge(i,k) {

   scalar markerArcLength = 20

   -- corner vertex positions
   vec2 pi = i.center
   vec2 pj = j.center
   vec2 pk = k.center

   -- edge arc data
   vec2 cIJ = ij.center
   vec2 cKI = ki.center
   scalar rIJ = ij.radius
   scalar rKI = ki.radius

   -- Euclidean interior angle
   scalar theta = angleBetween( pj-pi, pk-pi )
   -- CAT interior angle
   scalar beta = ij.alpha + ki.alpha + theta

   -- pick a radius for the arc that gives
   -- approximately the target arc length s
   -- (assuming s = rβ)
   scalar A.r = markerArcLength / beta

   -- start and end points for the corner arc
   vec2 p = circleCircleIntersection( cIJ, pi, rIJ, A.r )
   vec2 q = circleCircleIntersection( pi, cKI, A.r, rKI )

   shape angleMarker = Path {
      fillColor: none()
      strokeColor: Colors.clearGray
      d: arc( "open", p, q, (A.r,A.r), 0., 0, 0 )
      strokeWidth: .75
      ensureOnCanvas: false
   }
}

-- label for interior angle at corner of CAT
forall Angle A; Vertex i; Vertex j; Vertex k; Edge ij; Edge ki
where A has label; A := CATCorner( i, j, k ); ij := MakeEdge(i,j); ki := MakeEdge(k,i) {

   -- corner vertex positions
   vec2 pi = i.center
   vec2 pj = j.center
   vec2 pk = k.center

   -- angle bisector
   vec2 w = unit( unit(pj-pi) + unit(pk-pi) )

   scalar R = A.r + Global.labelSizeNum*.75

   shape A.labelText = Text {
      center: pi + R*w
      string: A.label
      fillColor: Colors.clearGray
      fontFamily: Global.labelFont
      fontSize: Global.labelSize
      fontStyle: Global.labelStyle
      ensureOnCanvas: false
   }
}

forall Angle A; Vertex i; Vertex j; Vertex k; Edge ij; Edge jk; Edge ki
where A := ExteriorAngle( i, j, k ); ij := MakeEdge(i,j); jk := MakeEdge(j,k); ki := MakeEdge(k,i) {
   scalar markerSize = 16
   scalar markerRadius = 14

   -- draw a dashed line tangent to
   -- the endpoint i of arc ki
   vec2 c = ki.center
   vec2 p = i.center
   vec2 u = rot90(unit(c-p))
   vec2 q = p - markerSize*u
   shape A.markerLine = Line {
      start: p
        end: q
      strokeColor: Colors.black
      strokeWidth: .5
      strokeDasharray: "1.5 1.5"
      ensureOnCanvas: false
   }

   -- draw a circular arc from the
   -- dashed line to the arc ij
   vec2 x0 = p - markerRadius*u
   vec2 x1 = circleCircleIntersection( ij.center, p, ij.radius, markerRadius )

   shape A.angleMarker = Path {
      fillColor: none()
      strokeColor: Colors.black
      d: arc( "open", x0, x1, (markerRadius,markerRadius), 0., 0, 0 )
      strokeWidth: .5
      --endArrowhead: true
      --arrowheadSize: .75
      ensureOnCanvas: false
   }

   shape A.angleMarkerFill = Path {
      d: wedge( i.center, x0, x1, (markerRadius,markerRadius), 0., 0, 0 )
      fillColor: Colors.clearGray
      strokeColor: none()
      ensureOnCanvas: false
   }

   layer A.angleMarker above A.angleMarkerFill
}

forall Circle C {
   vec2 C.center = (?,?)
   scalar C.radius = ?
}

-- draw the radius
forall Segment s; Circle C
where s := RadiusOf( C ) {

   -- optimize the direction of the radius
   scalar s.theta = ?

   -- unit vector in the direction of the radius
   vec2 s.u = ( cos(s.theta), sin(s.theta) )
   
   s.icon = Line {
      start: C.center
      end: C.center + C.radius*s.u
      strokeWidth: .75
      strokeColor: Colors.lightGray
      ensureOnCanvas: false
   }

   s.dot = Circle {
      center: C.center
      r: Global.dotSize
      fillColor: Colors.lightGray
      ensureOnCanvas: false
   }
}

-- draw the circle associated with the arc through a given edge
forall Circle C; Edge ij; Vertex i; Vertex j
where C := CircleThrough( ij ); ij := MakeEdge( i, j ) {

   -- copy the center and radius of the
   -- edge's circular arc, so that it
   -- can be more easily referenced by
   -- rules that reference this circle
   override C.center = ij.center
   override C.radius = ij.radius

   shape C.icon = Circle {
      center: C.center
      r: C.radius
      ensureOnCanvas: false
      fillColor: rgba( 0, 0, 0, .025 )
      strokeColor: Colors.clearGray
      strokeWidth: .75
   }
}

-- for a circle through an edge arc, draw the radius so
-- that it doesn't intersect the rest of the triangle
forall Segment s; Circle C; Edge ij; Vertex i; Vertex j
where s := RadiusOf(C); C := CircleThrough( ij ); ij := MakeEdge( i, j ) {

   vec2 ui = unit(i.center - C.center)
   vec2 uj = unit(j.center - C.center)
   override s.u = -unit( ui + uj )
}


