-- diagram dimensions (in px)
canvas {
   width = 320
   height = 240
}

-- some colors re-used throughout
Colors {
   color black = rgba(0,0,0,1)
   color white = rgba(1,1,1,1)
   color darkGray = rgba(.5,.5,.5,1)
   color lightGray = rgba(.9,.9,.9,1)
}

Global {
   -- default appearance for label text
   string labelFont = "Palatino"
   string labelSize = "12px"
   color labelColor = Colors.black

   vec2 p0 = (?,?)
   vec2 p1 = (?,?)
   vec2 p2 = (?,?)
   vec2 p3 = (?,?)
   vec2 p4 = (?,?)
   vec2 p5 = (?,?)

   scalar maxPerturbation = 30.
   ensure lessThan( norm(p0), maxPerturbation )
   ensure lessThan( norm(p1), maxPerturbation )
   ensure lessThan( norm(p2), maxPerturbation )
   ensure lessThan( norm(p3), maxPerturbation )
   ensure lessThan( norm(p4), maxPerturbation )
   ensure lessThan( norm(p5), maxPerturbation )

   shape box = Rectangle {
      center: (0,0)
      width: canvas.width
      height: canvas.height
      fillColor: none()
      stroke: none()
   }

   shape domain = Polygon {
      points: ( (150,-110)+p0, (0,-110)+p1, (-150,-110)+p2, (-150,110)+p3, (0,110)+p4, (150,110)+p5)
      --points: ((-117.1,17.2), (-120,2.4), (-119.1,-12.6), (-114.9,-27.3), (-107.8,-41.4), (-98.5,-54.5), (-87.4,-66), (-75.1,-75.7), (-62.1,-83.1), (-37.8,-90), (-13.9,-89.6), (9,-83.8), (29.9,-74.4), (48.3,-63.3), (63.2,-52.2), (73.8,-43.1), (79.5,-37.7), (86.4,-30.9), (94,-23), (101.5,-14.1), (108.5,-4.3), (114.4,6.4), (118.4,17.8), (120,29.8), (118.6,42.3), (115.3,51.8), (110.4,60.8), (104.1,68.9), (96.7,76.1), (88.5,81.9), (79.8,86.2), (70.8,88.7), (61.9,89.1), (53.1,87), (45.9,82.9), (39.6,77.4), (27.5,64.6), (20.6,58.6), (12.3,53.9), (2,51), (-6.2,50.5), (-13.3,51.6), (-19.7,53.8), (-31.9,59.3), (-38.6,61.8), (-46.2,63.3), (-55.3,63.5), (-64.9,62), (-74.4,59.1), (-83.7,54.8), (-92.4,49.2), (-100.4,42.6), (-107.3,34.9), (-112.9,26.4))
      fillColor: Colors.lightGray
      strokeColor: Colors.darkGray
      strokeWidth: 2.
      ensureOnCanvas: false
      cornerRadius: 10.
   }

   ensure contains( Global.box, Global.domain )

   shape domainName = Text {
      string: "Î©"
      center: (?,?)
      fontSize: Global.labelSize
      fontFamily: Global.labelFont
      fillColor: Colors.darkGray
   }

   layer domainName above domain
   layer box below domain

   ensure lessThan( signedDistance( domain, Global.domainName.center ), -10. )

   baseWidth = 1.5
}

forall Step s {
   shape s.boundary = Circle {
      center: (?,?)
      r: 1.
      --fillColor: rgba( .2, .6, .2, .2 )
      fillColor: none()
      strokeColor: Colors.black
      strokeWidth: Global.baseWidth
      ensureOnCanvas: false
   }

   -- signedDistance( shape, vec2 )

   shape s.dot = Circle {
      center: s.boundary.center
      r: 2.5
      fillColor: Colors.black
      ensureOnCanvas: false
   }

   vec2 c = s.boundary.center
   scalar w = canvas.width
   scalar h = canvas.height
   --scalar R = min( min( min( w/2-c[0], c[0]+w/2. ), h/2-c[1] ), c[1]+h/2. )
   scalar R = -signedDistance( Global.domain, c )
   override s.boundary.r = R - Global.baseWidth/2.

   ensure inRange( c[0], -w/2, w/2 )
   ensure inRange( c[1], -h/2, h/2 )

   shape s.shading = Image {
      center: s.boundary.center 
      width: s.boundary.r * 2.0
      height: s.boundary.r * 2.0
      href: "ball.svg"
      ensureOnCanvas: false
   }

   shape s.ball = Circle {
      center: s.boundary.center
      r: s.boundary.r
      fillColor: rgba( .2, .8, .2, .15 )
      strokeColor: none()
   }

   layer s.boundary above Global.domain
   layer s.dot above Global.domain
   layer s.shading above Global.domain
   layer s.shading below s.boundary
   layer s.ball above s.shading
   layer s.boundary above s.ball

   scalar s.shrinkFactor = .55
}

forall Step s
where s has label {

   shape s.labelText = Text {
      string: s.label
      center: (?,?)
      fontSize: Global.labelSize
      fontFamily: Global.labelFont
      fontStyle: "italic"
      fillColor: Global.labelColor
      strokeColor: Colors.white
      strokeWidth: 2.5
      strokeLinejoin: "round"
      paintOrder: "stroke"
   }

   encourage near( s.labelText, s.dot )
   ensure disjoint( s.labelText, s.dot, 2. )

   layer s.labelText above s.boundary
}

forall Step s
where isNested( s ) {
   override s.ball.fillColor = rgba( 1, 1, 1, .4 )
   override s.dot.fillColor = Colors.white
   override s.boundary.strokeColor = Colors.white

   override s.shrinkFactor = .45
}

forall Sample y; Step x
where y := sampleSource( x ) {

   shape y.dot = Circle {
      center: (?,?)
      r: 2
      fillColor: Colors.white
      strokeColor: Colors.black
      strokeWidth: 1
   }

   scalar R = norm(y.dot.center-x.boundary.center)
   scalar r = x.boundary.r
   ensure inRange( R, .2*r, .8*r )
}

forall Step y; Step x
where y := sampleInterior( x ) {
   scalar R = norm(y.dot.center-x.boundary.center)
   scalar r = x.boundary.r
   ensure inRange( R, .2*r, .8*r )

   ensure equal( y.boundary.r, .3 * x.boundary.r )
}

forall Sample y; Step x
where y := sampleSource( x ); y has label {

   shape y.labelText = Text {
      string: y.label
      center: (?,?)
      fontSize: Global.labelSize
      fontFamily: Global.labelFont
      fontStyle: "italic"
      fillColor: Global.labelColor
      strokeColor: Colors.white
      strokeWidth: 2.5
      strokeLinejoin: "round"
      paintOrder: "stroke"
   }

   encourage near( y.labelText, y.dot )
   ensure disjoint( y.labelText, y.dot, 2. )
}

forall Sample y; Step x
where y has label; y := sampleSource(x) {
   layer y.labelText above x.boundary
}


forall Step x0; Step x1
where x1 := sampleBoundary(x0) {
   ensure equal( norm(x1.boundary.center-x0.boundary.center), x0.boundary.r )
   layer x1.boundary above x0.boundary

   color walkColor = rgba( 0, 0, .7, 1 )

   shape walkLine = Line {
      start: x0.boundary.center
      end: x1.boundary.center
      strokeWidth: 2.
      strokeColor: walkColor
   }
   layer walkLine above Global.domain

   -- draw later steps of the walk as smaller
   -- balls (which will typically, but not always,
   -- be the behavior of the WoS algorithm)
   ensure equal( x1.boundary.r, x1.shrinkFactor * x0.boundary.r )
}

-- make sure the sample point isn't covered
-- by the next or previous shading in the walk
forall Step x0; Step x1; Sample y0
where x1 := sampleBoundary(x0); y0 := sampleSource(x0) {
   ensure disjoint( x1.boundary, y0.dot )
}
forall Step x0; Step x1; Sample y1
where x1 := sampleBoundary(x0); y1 := sampleSource(x1) {
   ensure disjoint( x0.boundary, y1.dot )
}

forall Step x {
   ensure disjoint( Global.domainName, x.boundary, 10. )
}

